import CurseForgeFile from './File.js';
import CurseForgeGame from './Game.js';
import CurseForgeMod from './Mod.js';
export class CurseForgeResponseError extends Error {
    path;
    status;
    statusText;
    constructor({ path, status, statusText }) {
        super(`API request to ${path} failed: ${status} (${statusText})`);
        this.path = path;
        this.status = status;
        this.statusText = statusText;
    }
}
class CurseForgeClient {
    #apiHost = 'https://api.curseforge.com';
    #apiKey;
    #fetch;
    static #dateRegex = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
    constructor(apiKey, options) {
        if (typeof apiKey !== 'string') {
            throw new TypeError(`CurseForgeClient constructor expects argument 1 to be string, received ${typeof apiKey}`);
        }
        this.#apiKey = apiKey;
        if (options?.fetch) {
            this.#fetch = options.fetch;
        }
        else {
            try {
                this.#fetch = fetch;
            }
            catch { }
        }
        if (typeof this.#fetch === 'undefined') {
            throw new TypeError('fetch() is not available in this environment. Please provide an implementation of fetch.');
        }
    }
    static #upgrade(object) {
        if (object === null || typeof object !== 'object') {
            return object;
        }
        const entries = Object.entries(object);
        for (const [key, value] of entries) {
            if (typeof value === 'string' && value.match(CurseForgeClient.#dateRegex)) {
                object[key] = new Date(value);
            }
            else if (typeof value === 'object') {
                object[key] = CurseForgeClient.#upgrade(value);
            }
        }
        return object;
    }
    async fetchUrl(path, options = {}) {
        options.headers = {
            ...options.headers,
            'x-api-key': this.#apiKey,
        };
        let url = `${this.#apiHost}${path}`;
        if (options.body && options.method === undefined) {
            options.method = 'POST';
            options.headers = {
                ...options.headers,
                'Content-Type': 'application/json',
            };
        }
        if (options.query) {
            const entries = Object.entries(options.query);
            if (entries.length > 0) {
                url = `${url}?${entries.map(([key, value]) => {
                    return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
                }).join('&')}`;
            }
        }
        const response = await this.#fetch(url, options);
        if (response.status === 200) {
            const data = await response.json();
            return CurseForgeClient.#upgrade(data);
        }
        else {
            throw new CurseForgeResponseError({
                path,
                status: response.status,
                statusText: response.statusText,
            });
        }
    }
    #getArrayResponse(CurseForgeType, data) {
        return data.map((rawResponse) => {
            return new CurseForgeType(this, rawResponse);
        });
    }
    #getPaginatedResponse(CurseForgeType, data) {
        return {
            pagination: data.pagination,
            data: this.#getArrayResponse(CurseForgeType, data.data),
        };
    }
    async getGames(options) {
        const data = await this.fetchUrl('/v1/games', { query: options });
        return this.#getPaginatedResponse(CurseForgeGame, data);
    }
    async getGame(gameId) {
        const data = await this.fetchUrl(`/v1/games/${gameId}`);
        return new CurseForgeGame(this, data.data);
    }
    async getVersions(gameId) {
        const data = await this.fetchUrl(`/v1/games/${gameId}/versions`);
        return data.data;
    }
    async getVersionTypes(gameId) {
        const { data } = await this.fetchUrl(`/v1/games/${gameId}/version-types`);
        return data;
    }
    async getCategories(gameId, options) {
        const { data } = await this.fetchUrl('/v1/categories', { query: {
                gameId,
                ...options,
            } });
        return data;
    }
    async searchMods(gameId, options) {
        const data = await this.fetchUrl('/v1/mods/search', { query: {
                gameId,
                ...options,
            } });
        return this.#getPaginatedResponse(CurseForgeMod, data);
    }
    async getMod(modId) {
        const { data } = await this.fetchUrl(`/v1/mods/${modId}`);
        return new CurseForgeMod(this, data);
    }
    async getMods(modIds) {
        const { data } = await this.fetchUrl('/v1/mods', {
            body: JSON.stringify({ modIds }),
        });
        return this.#getArrayResponse(CurseForgeMod, data);
    }
    async getFeaturedMods(options) {
        const { data: { featured, popular, recentlyUpdated } } = await this.fetchUrl('/v1/mods/featured', {
            body: JSON.stringify(options),
        });
        return {
            featured: this.#getArrayResponse(CurseForgeMod, featured),
            popular: this.#getArrayResponse(CurseForgeMod, popular),
            recentlyUpdated: this.#getArrayResponse(CurseForgeMod, recentlyUpdated),
        };
    }
    async getModDescription(modId, options) {
        const { data } = await this.fetchUrl(`/v1/mods/${modId}/description`, { query: options });
        return data;
    }
    async getModFile(modId, fileId) {
        const { data } = await this.fetchUrl(`/v1/mods/${modId}/files/${fileId}`);
        return new CurseForgeFile(this, data);
    }
    async getModFiles(modId, options) {
        const data = await this.fetchUrl(`/v1/mods/${modId}/files`, { query: options });
        return this.#getPaginatedResponse(CurseForgeFile, data);
    }
    async getFiles(fileIds) {
        const { data } = await this.fetchUrl('/v1/mods/files', {
            body: JSON.stringify({ fileIds }),
        });
        return this.#getArrayResponse(CurseForgeFile, data);
    }
    async getModFileChangelog(modId, fileId) {
        const { data } = await this.fetchUrl(`/v1/mods/${modId}/files/${fileId}/changelog`);
        return data;
    }
    async getModFileDownloadURL(modId, fileId) {
        const { data } = await this.fetchUrl(`/v1/mods/${modId}/files/${fileId}/download-url`);
        return data;
    }
    async getFingerprintsMatches(fingerprints) {
        const { data } = await this.fetchUrl('/v1/fingerprints', {
            body: JSON.stringify({ fingerprints }),
        });
        return {
            ...data,
            exactMatches: data.exactMatches.map((exactMatchRaw) => {
                return {
                    ...exactMatchRaw,
                    file: new CurseForgeFile(this, exactMatchRaw.file),
                    latestFiles: this.#getArrayResponse(CurseForgeFile, exactMatchRaw.latestFiles),
                };
            }),
            partialMatches: data.partialMatches.map((partialMatchRaw) => {
                return {
                    ...partialMatchRaw,
                    file: new CurseForgeFile(this, partialMatchRaw.file),
                    latestFiles: this.#getArrayResponse(CurseForgeFile, partialMatchRaw.latestFiles),
                };
            }),
        };
    }
    async getFingerprintsFuzzyMatches(options) {
        const { data } = await this.fetchUrl('/v1/fingerprints/fuzzy', {
            body: JSON.stringify(options),
        });
        return data.fuzzyMatches.map((fuzzyMatchRaw) => {
            return {
                ...fuzzyMatchRaw,
                file: new CurseForgeFile(this, fuzzyMatchRaw.file),
                latestFiles: this.#getArrayResponse(CurseForgeFile, fuzzyMatchRaw.latestFiles),
            };
        });
    }
    async getMinecraftVersions(options) {
        const { data } = await this.fetchUrl('/v1/minecraft/version', { query: options });
        return data;
    }
    async getSpecificMinecraftVersion(gameVersionString) {
        const { data } = await this.fetchUrl(`/v1/minecraft/version/${gameVersionString}`);
        return data;
    }
    async getMinecraftModLoaders(options) {
        const { data } = await this.fetchUrl('/v1/minecraft/modloader', { query: options });
        return data;
    }
    async getSpecificMinecraftModLoader(modLoaderName) {
        const { data } = await this.fetchUrl(`/v1/minecraft/modloader/${modLoaderName}`);
        return data;
    }
}
export default CurseForgeClient;
